<!doctype html>

<head>
    <meta charset="utf-8">
    <meta name="author" content="Paul Lewis" />
    <meta name="viewport" content="width=device-width">
    <title></title>
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
            background: #777;
            overflow: hidden;
        }
        
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        #instructions {
            width: 100%;
            height: 100%;
            display: box;
            box-orient: horizontal;
            box-pack: center;
            box-align: center;
            color: #ffffff;
            text-align: center;
            font-family: Arial;
            font-size: 14px;
            line-height: 24px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="blocker">
        <div id="instructions">
            <span style="font-size:36px">Click to play</span>
            <br /><br /> Move: WASD<br /> Jump: SPACE<br /> Look: MOUSE
        </div>
    </div>
    <div id="container"></div>

    <!-- Principal -->
    <script src="./third_party/build/three.js"></script>
    <!-- Loaders -->
    <!-- <script src="./third_party/loaders/ColladaLoader.js"></script> -->
    <!-- Controls -->
    <script src="./third_party/OrbitControls.js"></script>
    <script src="./third_party/FirstPersonControls.js"></script>
    <script src="./third_party/PointerLockControls.js"></script>
    <script src="./third_party/libs/stats.min.js"></script>

    <script>
        // import { PointerLockControls } from './third_party/PointerLockControls.js';

        let camera, scene, renderer;
        let clock = new THREE.Clock();

        // https://blog.cogapp.com/how-to-create-a-virtual-3d-gallery-using-iiif-and-three-js-ad6766e45d3f
        let firstPersonControl, pointerLockControl;

        // Resize the renderer and the camera if we resize the window
        window.addEventListener('resize', function() {
            renderer.setSize(window.innerWidth, window.innerHeight);

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // view-source:https://threejs.org/examples/webgl_geometry_minecraft.html

        // function createSphere(arc, tube, radial_segment, tubular_segment, material) {
        const load = function() {
            // Set the scene size.
            const SCREEN_WIDTH = window.innerWidth;
            const SCREEN_HEIGHT = window.innerHeight;

            // Set some camera attributes.
            const VIEW_ANGLE = 45;
            const ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
            const NEAR = .1;
            const FAR = 10000;

            // Get the DOM element to attach to
            const container = document.querySelector('#container');
            // Create a WebGL renderer and starts it
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            // Attach 1the renderer-supplied DOM element.
            container.appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0x01374c);
            // scene.fog = new THREE.FogExp2(0x9999ff, 0.00025);
            // scene.fog = new THREE.Fog(scene.background, 10, 20);

            // const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
            // light.position.set( 0.5, 1, 0.75 );
            // scene.add( light );

            // Point de lumière
            // const pointLight = new THREE.PointLight(0xFFFFFF);
            // pointLight.position.x = 10;
            // pointLight.position.y = 50;
            // pointLight.position.z = 130;
            // scene.add(pointLight);

            // Lumière ambiante
            // const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
            // scene.add(ambientLight);

            // Lumière directionnelle
            // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            // directionalLight.position.set(1, -1, 0).normalize();
            // scene.add(directionalLight);

            // collada
            // const loadingManager = new THREE.LoadingManager(function () {});
            // const colladaLoader = new THREE.ColladaLoader(loadingManager);
            // colladaLoader.load('./models/pion/model.dae', function (collada) {});

            // Ground
            // window.addEventListener('keydown', KeyDown);
            // window.addEventListener('keyup', KeyUp);
            // https://www.youtube.com/watch?v=UUilwGxIj_Q
            // https://makc3d.wordpress.com/2014/07/20/thre
            // https://free3d.com/fr/3d-models/ville
            // https://www.youtube.com/watch?v=6oFvqLfRnsU
            // https://blog.webmaestro.fr/character-controls-three-js/

            meshFloor();
            // meshBoxes()

            function meshBoxes() {
                cubes = [];
                for (let i = 0; i < 100; i++) {
                    // geo = new THREE.BoxGeometry(Math.random() * 100, Math.random() * 100, Math.random() * 100)
                    geo = new THREE.BoxGeometry(Math.random() * 100, Math.random() * 100, Math.random() * 100)
                    mat = new THREE.MeshBasicMaterial({
                        wireframe: true
                    })
                    switch (i % 3) {
                        case 0:
                            mat.color = new THREE.Color(0xff0000)
                            break;
                        case 1:
                            mat.color = new THREE.Color(0xffff00)
                            break;
                        case 2:
                            mat.color = new THREE.Color(0x0000ff)
                            break;
                    }
                    const cube = new THREE.Mesh(geo, mat)
                    cubes.push(cube)
                }
                cubes.forEach((c) => {
                    c.position.x = (Math.random() * 1000) - 500
                    c.position.z = (Math.random() * 1000) - 500
                    c.geometry.computeBoundingBox()
                    c.position.y = (c.geometry.boundingBox.max.y - c.geometry.boundingBox.min.y) / 2
                    scene.add(c)
                });
            }

            function meshFloor() {
                meshFloorTexture = new THREE.TextureLoader().load('./textures/floor.jpg');
                meshFloorTexture.wrapS = meshFloorTexture.wrapT = THREE.RepeatWrapping;
                meshFloorTexture.repeat.set(10, 10);
                meshFloor = new THREE.Mesh(
                    new THREE.PlaneGeometry(1000, 1000, 20, 20), // x, y ,nb segmentsX
                    new THREE.MeshBasicMaterial({
                        // map: meshFloorTexture,
                        side: THREE.DoubleSide,
                        color: 0x00ff00,

                        // color: 0x77cc00,
                        wireframe: true
                    })
                );
                meshFloor.position.set(0, -0.5, 0);
                meshFloor.rotation.x = Math.PI / 2;
                scene.add(meshFloor);
            }


            // Creation de la petite sphere

            sphereGeometry2 = new THREE.SphereGeometry(20, 32, 32);

            sphereMaterial2 = new THREE.MeshStandardMaterial({
                map: new THREE.TextureLoader().load('./venusmap.png')
            });

            sphereObject = new THREE.Mesh(sphereGeometry2, sphereMaterial2);
            sphereObject.position.set(Math.random() * 400, 40, Math.random() * 200);
            scene.add(sphereObject);
            sphereObject.angle = 100;
            sphereObject.add(
                new THREE.PointLight(color = '#ff0000', intensity = 2)
            );
            sphere = scene.getObjectByName("sphere");


            // Attraper la sphere

            //var controls;
            //var message = document.getElementById('message');
            //if (sphereObject.position.distanceTo(controls.getObject().position) < 50) {
            //blocker.style.display = '';
            //instructions.innerHTML = "Bravo ! tu as trouvé la sphère";
            //instructions.style.display = '';
            //sphereObject.position.set(Math.random() * 400, 40, Math.random() * 200);
            //}


            // Cube
            cube = new THREE.Mesh(
                new THREE.BoxGeometry(50, 50, 50),
                new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true // if we want to see the squeletton
                })
            );
            cube.lenght = 50;
            cube.position.set(0, 0 + cube.lenght / 2 + 50, 0);
            cube.velocity = 2;
            cube.canJump = true; //https://www.reddit.com/r/gamedev/comments/98kcpg/3d_jumping_algorithm/
            cube.jumpHeight = 75;
            cube.gravity = .7;
            scene.add(cube);

            // Sky
            var skyBoxGeometry = new THREE.CubeGeometry(FAR - 10, FAR - 10, FAR - 10);
            var skyBoxMaterial = new THREE.MeshBasicMaterial({
                color: 0x9966ff,
                side: THREE.BackSide
            });
            var skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
            scene.add(skyBox);

            // 75°, ratio of browser, ,distance
            //https://miro.medium.com/max/1400/1*HLlvkSfd4esYDN8BtNwGCQ.png
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.set(scene.position.x, scene.position.y + 200, scene.position.z + 300)
                // camera.position.set(0, 50, 0)
            camera.lookAt(cube.position);
            scene.add(camera);

            // camera.lookAt(cube.position);
            // cube.add(camera);

            // Controls
            // https://codepen.io/tembling/pen/reZjEw?editors=1010
            // const orbitControl = new THREE.OrbitControls(camera, renderer.domElement);
            // const pointerLockControl = new THREE.PointerLockControls( camera, document.body );
            // pointerLockControl = new THREE.PointerLockControls( camera, renderer.domElement );
            // pointerLockControl = new THREE.PointerLockControls(camera, document.body);
            console.log(renderer.domElement)
            pointerLockControl = new THREE.PointerLockControls(camera, renderer.domElement);

            // pointerLockControl.addEventListener('change', () => console.log("Controls Change"))

            pointerLockControl.lock();
            scene.add(pointerLockControl.getObject());

            // Move the pointerLock
            pointerLockControl.getObject().position.z = 100;
            // pointerLockControl.getObject().position.y = 0;

            // firstPersonControl = new THREE.FirstPersonControls(camera, renderer.domElement);
            // firstPersonControl.movementSpeed = 1000;
            // firstPersonControl.lookSpeed = 0.125;
            // firstPersonControl.lookVertical = false;

            console.log(camera.position);

            var blocker = document.getElementById('blocker');
            var instructions = document.getElementById('instructions');

            // Add to lock to our instructions
            instructions.addEventListener('click', function() {
                pointerLockControl.lock();
            }, false);

            // Lock and unlock
            pointerLockControl.addEventListener('lock', function() {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            pointerLockControl.addEventListener('unlock', function() {
                blocker.style.display = 'block';
                instructions.style.display = '';
            });
            scene.add(pointerLockControl.getObject());

            // When keyoboard is pressed
            var onKeyDown = function(event) {
                console.log(event)
                switch (event.keyCode) {
                    case 38: // up
                    case 90: // z
                        cube.moveForward = true;
                        // pointerLockControl.moveForward(.25)
                        break;
                    case 37: // left
                    case 81: // q
                        // cube.moveLeft = true;
                        break;
                    case 40: // down
                    case 83: // s
                        // cube.moveBackward = true;
                        break;
                    case 39: // right
                    case 68: // d
                        // cube.moveRight = true;
                        break;
                    case 32: // space
                        if (cube.canJump === true) {
                            console.log("ok")
                                // cube.velocity.y += 350;
                            cube.position.y += cube.jumpHeight;
                            // cube.position.y += 5;
                        }
                        cube.canJump = false;
                        break;
                }
            };
            // When keyoboard is realeased
            // var onKeyUp = function (event) {
            //     switch (event.keyCode) {
            //         case 38: // up
            //         case 90: // z
            //             cube.moveForward = false;
            //             break;
            //         case 37: // left
            //         case 81: // q
            //             cube.moveLeft = false;
            //             break;
            //         case 40: // down
            //         case 83: // s
            //             cube.moveBackward = false;
            //             break;
            //         case 39: // right
            //         case 68: // d
            //             cube.moveRight = false;
            //             break;
            //     }
            // };
            // document.addEventListener('keydown', onKeyDown);
            // document.addEventListener('keyup', onKeyUp, false);

            // var cubeMaterialArray = [];
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0xff3333
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0xff8800
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0xffff33
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0x33ff33
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0x3333ff
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0x8833ff
            // }));
            // var cubeMaterials = new THREE.MeshFaceMaterial(cubeMaterialArray);
            // var cubeGeometry = new THREE.CubeGeometry(100, 100, 100, 1, 1, 1);
            // cubeComplexe = new THREE.Mesh(cubeGeometry, cubeMaterials);
            // cubeComplexe.position.set(-100, 50, -50);
            // scene.add(cubeComplexe);

            // Help axes
            var axes = new THREE.AxesHelper(1000);
            scene.add(axes);

            // Stats
            stats = new Stats();
            // stats.domElement.style.position = 'absolute';
            // stats.domElement.style.bottom = '0px';
            // stats.domElement.style.zIndex = 100;
            container.appendChild(stats.domElement);
        }

        // Game Logic
        let update = function() {
            // cube.rotation.x += .01;
            // cube.rotation.y += .03;

            // cube.position.z += 1;

            // camera.position.x += 1
            // camera.position.y += 1
            // camera.position.z -= 1

            // controls.update();
            // firstPersonControl.update(clock.getDelta());
            // pointerLockControl.update(clock.getDelta());
            // pointerLockControl.getObject().position.y += 1;
            // pointerLockControl.getObject().position.z += 1;
            // if (pointerLockControl.isLocked === true) {
            //     console.log("ya")
            // }

            // Cube Movements
            // if (cube.moveRight) {
            //     cube.position.x += cube.velocity;
            // }
            // if (cube.moveLeft) {
            //     cube.position.x -= cube.velocity;
            // }
            // if (cube.moveForward) {
            //     cube.position.z -= cube.velocity;
            // }
            // if (cube.moveBackward) {
            //     cube.position.z += cube.velocity;
            // }


            // cube.velocity.y += cube.gravity;
            // velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

            // Gravity
            if (Math.round(cube.position.y) > cube.lenght / 2) {
                cube.position.y -= cube.gravity;
                cube.canJump = false;
                //     // cube.position.y -= cube.velocity;
            } else {
                //     cube.gravity = 0
                // cube.position.y = cube.lenght / 2 +50;
                cube.canJump = true;
            }

            stats.update();
        }

        // Run game loop(update, render, repeat)
        const gameLoop = function() {
            requestAnimationFrame(gameLoop);
            update();

            // Render scene
            renderer.render(scene, camera);
        }

        load();
        gameLoop();

        // Axes to help up
        function helpAxes() {
            // let axesHelper1 = new THREE.AxesHelper(50);
            // let axesHelper2 = new THREE.AxesHelper(50);
            // let axesHelper3 = new THREE.AxesHelper(50);

            // scene.add(axesHelper1);
            // sphere.add(axesHelper1);
            // obj3d.add(axesHelper2);
            // pion.add(axesHelper3);
        }

        function createForme(form, material) {
            // Create a new mesh with sphere geometry
            const forme = new THREE.Mesh(form, material);
            forme.angle = Math.random(0, 360);

            // Reset of angles
            if (forme.angle > 360) {
                forme.angle = 1;
            } else if (forme.angle < 1) {
                forme.angle = 360;
            }

            return forme;
        }

        // Schedule the first frame.
        requestAnimationFrame(update);
    </script>
</body>

</html>