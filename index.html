<!doctype html>

<head>
    <meta charset="utf-8">
    <meta name="author" content="Paul Lewis" />
    <meta name="viewport" content="width=device-width">
    <title></title>
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
            background: #777;
            overflow: hidden;
        }

        #instructions {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);

            display: table;

            color: #ffffff;
            text-align: center;
            font-family: Arial;
            font-size: 14px;
            margin: auto;

            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="instructions">
        <span>Cliquez afin de jouer</span>
        Déplacements : ZSQD ou Flèches<br />
        Sauter : Espace<br />
        Regarder : Souris
    </div>
    <div id="container"></div>

    <!-- Principal -->
    <script src="./third_party/build/three.js"></script>
    <!-- Loaders -->
    <!-- <script src="./third_party/loaders/ColladaLoader.js"></script> -->
    <!-- Controls -->
    <script src="./third_party/OrbitControls.js"></script>
    <script src="./third_party/FirstPersonControls.js"></script>
    <script src="./third_party/PointerLockControls.js"></script>
    <script src="./third_party/libs/stats.min.js"></script>

    <script>
        let camera, scene, renderer;
        let clock = new THREE.Clock();

        // view-source:https://threejs.org/examples/webgl_geometry_minecraft.html
        let firstPersonControl, pointerLockControl;
        let loader = new THREE.TextureLoader();

        // Resize the renderer and the camera if we resize the window
        window.addEventListener('resize', function () {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // function createSphere(arc, tube, radial_segment, tubular_segment, material) {
        const load = function () {
            // Set the scene size.
            const SCREEN_WIDTH = window.innerWidth;
            const SCREEN_HEIGHT = window.innerHeight;

            // Set some camera attributes.
            const VIEW_ANGLE = 45;
            const ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
            const NEAR = .1;
            const FAR = 10000;

            // Get the DOM element to attach to
            const container = document.querySelector('#container');

            // Create a WebGL renderer and starts it
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

            // Attach 1the renderer-supplied DOM element.
            container.appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0x01374c);
            // scene.fog = new THREE.FogExp2(0x9999ff, 0.00025);
            // scene.fog = new THREE.Fog(scene.background, 10, 20);

            // Lights
            // const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
            // light.position.set( 0.5, 1, 0.75 );
            // scene.add( light );

            // Point de lumière
            // const pointLight = new THREE.PointLight(0xFFFFFF);
            // pointLight.position.x = 10;
            // pointLight.position.y = 50;
            // pointLight.position.z = 130;
            // scene.add(pointLight);

            // Lumière ambiante
            // const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
            // scene.add(ambientLight);

            // Lumière directionnelle
            // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            // directionalLight.position.set(1, -1, 0).normalize();
            // scene.add(directionalLight);

            // collada
            // const loadingManager = new THREE.LoadingManager(function () {});
            // const colladaLoader = new THREE.ColladaLoader(loadingManager);
            // colladaLoader.load('./models/pion/model.dae', function (collada) {});

            // Ground
            // window.addEventListener('keydown', KeyDown);
            // window.addEventListener('keyup', KeyUp);
            // https://www.youtube.com/watch?v=UUilwGxIj_Q
            // https://makc3d.wordpress.com/2014/07/20/thre
            // https://free3d.com/fr/3d-models/ville
            // https://www.youtube.com/watch?v=6oFvqLfRnsU
            // https://blog.webmaestro.fr/character-controls-three-js/

            meshFloor();
            // meshBoxes()
            meshBox()

            // 75°, ratio of browser, ,distance
            //https://miro.medium.com/max/1400/1*HLlvkSfd4esYDN8BtNwGCQ.png
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera.position.set(scene.position.x, scene.position.y + 50, scene.position.z + 300)
            // camera.direction = new THREE.Vector3();
            camera.velocity = 2;
            camera.canJump = true; //https://www.reddit.com/r/gamedev/comments/98kcpg/3d_jumping_algorithm/
            camera.jumpHeight = 75;
            camera.gravity = .7;
            // camera.getWorldDirection( camera.direction );
            // camera.position.add( camera.direction );
            // camera.distance = 100;
            // camera.position.add( camera.direction.multiplyScalar(camera.distance) );
            camera.lookAt(0, 50, 0);
            meshFloor.add(camera);

            // Controls
            // https://codepen.io/tembling/pen/reZjEw?editors=1010
            // const orbitControl = new THREE.OrbitControls(camera, renderer.domElement);
            // const pointerLockControl = new THREE.PointerLockControls( camera, document.body );

            // Allow to focus the window
            pointerLockControl = new THREE.PointerLockControls(camera, renderer.domElement);
            scene.add(pointerLockControl.getObject());

            // firstPersonControl = new THREE.FirstPersonControls(camera, renderer.domElement);
            // firstPersonControl.movementSpeed = 1000;
            // firstPersonControl.lookSpeed = 0.125;
            // firstPersonControl.lookVertical = false;

            var instructions = document.getElementById('instructions');
            // Add to lock to our instructions
            instructions.addEventListener('click', function () {
                pointerLockControl.lock();
            }, false);

            // Lock and unlock
            pointerLockControl.addEventListener('lock', function () {
                instructions.style.display = 'none';
            });
            pointerLockControl.addEventListener('unlock', function () {
                instructions.style.display = '';
            });

            // When keyoboard is pressed
            var onKeyDown = function (event) {
                console.log(event)
                switch (event.keyCode) {
                    case 38: // up
                    case 90: // z
                        camera.moveForward = true;
                        // pointerLockControl.moveForward(.25)
                        // camera.getWorldDirection( camera.direction ); // CHAGNED
                        // camera.position.add(camera.direction.multiplyScalar(2));
                        // camera.position.x -= 50;
                        // camera.translateX(-5);
                        break;
                    case 40: // down
                    case 83: // s
                        camera.moveBackward = true;
                        break;
                    case 37: // left
                    case 81: // q
                        // cube.moveLeft = true;
                        camera.moveLeft = true;
                        break;
                    case 39: // right
                    case 68: // d
                        // cube.moveRight = true;
                        camera.moveRight = true;
                        break;
                    case 32: // space
                        if (camera.canJump === true) {
                            console.log("ok")
                            // cube.velocity.y += 350;
                            // cube.position.y += 5;
                        }
                        camera.canJump = false;
                        break;
                    case 16: // shift
                        camera.moveMore = true;
                        break;
                }

            };
            // When keyoboard is realeased
            var onKeyUp = function (event) {
                switch (event.keyCode) {
                    case 38: // up
                    case 90: // z
                        camera.moveForward = false;
                        break;
                    case 37: // left
                    case 81: // q
                        camera.moveLeft = false;
                        break;
                    case 40: // down
                    case 83: // s
                        camera.moveBackward = false;
                        break;
                    case 39: // right
                    case 68: // d
                        camera.moveRight = false;
                        break;
                    case 16: // shift
                        camera.moveMore = false;
                        break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp, false);

            meshSphere();
            // sphere = scene.getObjectByName("sphere");

            // Catch the Sphere
            //var controls;
            //var message = document.getElementById('message');
            //if (sphereObject.position.distanceTo(controls.getObject().position) < 50) {
            //blocker.style.display = '';
            //instructions.innerHTML = "Bravo ! tu as trouvé la sphère";
            //instructions.style.display = '';
            //sphereObject.position.set(Math.random() * 400, 40, Math.random() * 200);
            //}


            // Help axes
            var axes = new THREE.AxesHelper(1000);
            scene.add(axes);

            // Stats
            stats = new Stats();
            container.appendChild(stats.domElement);
        }

        // Game Logic
        let update = function () {
            // If we are in the window when it is locked
            if (pointerLockControl.isLocked) {
                // firstPersonControl.update(clock.getDelta());

                // pointerLockControl.update(clock.getDelta());
                // Move the pointerLock
                // pointerLockControl.getObject().position.z = 100;
                // pointerLockControl.getObject().position.y = 0;
                // if (pointerLockControl.isLocked === true) {
                //     console.log("ya")
                // }
                // console.log(camera.moveRight)

                // Cube Movements
                // if (Math.round(camera.position.y >= 50)) {
                // camera.position.y = 50

                // direction = camera.getWorldDirection();
                // console.log(camera.getWorldDirection().x)

                // Speed up
                if (camera.moveMore && camera.moveForward) {
                    camera.translateZ(-10);
                }
                // Moves
                if (camera.moveForward) {
                    camera.translateZ(-5);
                    camera.position.y = 50;
                }
                if (camera.moveBackward) {
                    camera.translateZ(5);
                    camera.position.y = 50;
                }
                if (camera.moveRight) {
                    camera.translateX(5);
                }
                if (camera.moveLeft) {
                    // camera.position.x -= camera.velocity;
                    camera.translateX(-5);
                }
                // } 

                // Fix camera on the ground
                // if (camera.position.y > 50 || camera.position.y < 50) {
                if (camera.position.y < 50) {
                    camera.position.y = 50;
                };

                // Gravity
                // if (camera.position.y > scene.position + 50) {
                // camera.position.y -= camera.gravity;
                //     camera.position.y = 100;
                //     // camera.canJump = true;
                // } 
                // else {
                // cube.gravity = 0
                // cube.position.y = cube.lenght / 2 +50;
                // cube.canJump = true;
                // }

                stats.update();
            }
            // }
        }

        // Run game loop(update, render, repeat)
        const gameLoop = function () {
            requestAnimationFrame(gameLoop);
            update();

            // Render scene
            renderer.render(scene, camera);
        }

        load();
        gameLoop();

        // Schedule the first frame.
        requestAnimationFrame(update);

        // Axes to help up
        function helpAxes() {
            // let axesHelper1 = new THREE.AxesHelper(50);
            // let axesHelper2 = new THREE.AxesHelper(50);
            // let axesHelper3 = new THREE.AxesHelper(50);

            // scene.add(axesHelper1);
            // sphere.add(axesHelper1);
            // obj3d.add(axesHelper2);
            // pion.add(axesHelper3);
        }



        function meshSphere() {
            // Create the sphere
            const sphere2Texture = loader.load('./textures/sphere2.png')
            sphere2 = new THREE.Mesh(
                new THREE.SphereGeometry(20, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: sphere2Texture,
                    side: THREE.FrontSide
                })
            )
            sphere2.position.set(0, 50, 0);
            sphere2.angle = 100;
            sphere2.add(
                new THREE.PointLight(color = '#ff0000', intensity = 2)
            );
            scene.add(sphere2);
        }

        // function createForme(form, material) {
        //     // Create a new mesh with sphere geometry
        //     const forme = new THREE.Mesh(form, material);

        //     // Reset of angles
        //     if (forme.angle > 360) {
        //         forme.angle = 1;
        //     } else if (forme.angle < 1) {
        //         forme.angle = 360;
        //     }

        //     return forme;
        // }
        function meshComplexBoxes() {
                        // var cubeMaterialArray = [];
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0xff3333
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0xff8800
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0xffff33
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0x33ff33
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0x3333ff
            // }));
            // cubeMaterialArray.push(new THREE.MeshBasicMaterial({
            //     color: 0x8833ff
            // }));
            // var cubeMaterials = new THREE.MeshFaceMaterial(cubeMaterialArray);
            // var cubeGeometry = new THREE.CubeGeometry(100, 100, 100, 1, 1, 1);
            // cubeComplexe = new THREE.Mesh(cubeGeometry, cubeMaterials);
            // cubeComplexe.position.set(-100, 50, -50);
            // scene.add(cubeComplexe);
        }

        function meshBoxes() {
            cubes = [];
            for (let i = 0; i < 100; i++) {
                // geo = new THREE.BoxGeometry(Math.random() * 100, Math.random() * 100, Math.random() * 100)
                geo = new THREE.BoxGeometry(Math.random() * 100, Math.random() * 100, Math.random() * 100)
                mat = new THREE.MeshBasicMaterial({
                    wireframe: true
                })
                switch (i % 3) {
                    case 0:
                        mat.color = new THREE.Color(0xff0000)
                        break;
                    case 1:
                        mat.color = new THREE.Color(0xffff00)
                        break;
                    case 2:
                        mat.color = new THREE.Color(0x0000ff)
                        break;
                }
                const cube = new THREE.Mesh(geo, mat)
                cubes.push(cube)
            }
            cubes.forEach((c) => {
                c.position.x = (Math.random() * 1000) - 500
                c.position.z = (Math.random() * 1000) - 500
                c.geometry.computeBoundingBox()
                c.position.y = (c.geometry.boundingBox.max.y - c.geometry.boundingBox.min.y) / 2
                scene.add(c)
            });
        }

        function meshFloor() {
            const meshFloorTexture = loader.load('./textures/floor.jpg');
            meshFloorTexture.wrapS = meshFloorTexture.wrapT = THREE.RepeatWrapping;
            meshFloorTexture.repeat.set(1, 1);
            meshFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200, 20, 20), // x, y ,nb segmentsX
                new THREE.MeshBasicMaterial({
                    map: meshFloorTexture,
                    side: THREE.DoubleSide
                    // color: 0x00ff00,
                    // wireframe: true,
                })
            );
            // meshFloor.position.set(0, -.5, 0);
            meshFloor.rotation.x = Math.PI / 2;
            scene.add(meshFloor);

            // console.log( meshFloor.geometry.parameters.width);
            console.log(meshFloor.geometry.parameters.height);
        }

        function meshBox() {
            const lenght = 100;
            const cube = new THREE.Mesh(
                new THREE.BoxGeometry(lenght, lenght, lenght),
                new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true
                })
            );

            // offsetX = Math.random(meshFloor.position.x - lenght/2, )
            // offsetX = Math.random(-500, meshFloor.geometry.parameters.width - lenght * 1.5)
            offsetX = Math.floor(Math.random() * meshFloor.geometry.parameters.width - lenght * 1.5)
            console.log(offsetX)
            cube.position.set(offsetX, meshFloor.position.y, meshFloor.position.z - 50);
            meshFloor.add(cube);
        }

        function meshSky() {
            // Sky
            var skyBoxGeometry = new THREE.CubeGeometry(FAR - 10, FAR - 10, FAR - 10);
            var skyBoxMaterial = new THREE.MeshBasicMaterial({
                color: 0x9966ff,
                side: THREE.BackSide
            });
            var skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
            scene.add(skyBox);
        }
    </script>
</body>

</html>